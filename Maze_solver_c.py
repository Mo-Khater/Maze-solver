# -*- coding: utf-8 -*-
"""Untitled32 (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qhEhRp3l8SXUDSP4qWATOOuhf9QdTDdB
"""

import random
from PIL import Image, ImageDraw

def parse_maze(filename):
    with open(filename, 'r') as file:
        maze = [list(line.rstrip()) for line in file.readlines()]

    # To make all rows the same length
    max_len = max(len(row) for row in maze)
    for row in maze:
        row.extend(' ' * (max_len - len(row)))
    return maze


def maze_to_image(maze, final_path=None, cell_size=50, output_file='maze_solution.png'):
    cell_size = 50
    rows = len(maze)
    cols = len(maze[0])

    canvas.config(scrollregion=(0, 0, cols * cell_size, rows * cell_size))

    canvas.delete("all")
    for y, line in enumerate(maze):
        for x, char in enumerate(line):
            color = "#FFFFFF"
            if maze[y][x] == '#':
                color = "#000000"
            elif maze[y][x] == 'A':
                color = "#0000FF"
            elif maze[y][x] == 'B':
                color = "#008000"
            elif maze[y][x] == 'o':  # This is the final path
                color = "#FFFF00"
        
            canvas.create_rectangle(x * cell_size, y * cell_size,
                                    (x + 1) * cell_size, (y + 1) * cell_size,
                                    fill=color, outline="#2F4F4F")

def find_start_and_end(maze):
    start, end = None, None
    for i in range(len(maze)):
        for j in range(len(maze[i])):
            if maze[i][j] == 'A':
                start = (i, j)
            elif maze[i][j] == 'B':
                end = (i, j)
    return start, end


def generate_population(start, end, pop_size, maze, rows, columns):
    population = []
    for _ in range(pop_size):
        path = []
        current = start
        path.append(current)
        while current != end:
            move = random.choice(['N', 'S', 'E', 'W'])
            next_step = current
            if move == 'N' and current[0] > 0 and maze[current[0] - 1][current[1]] != '#':
                next_step = (current[0] - 1, current[1])
            elif move == 'S' and current[0] < rows - 1 and maze[current[0] + 1][current[1]] != '#':
                next_step = (current[0] + 1, current[1])
            elif move == 'E' and current[1] < columns - 1 and maze[current[0]][current[1] + 1] != '#':
                next_step = (current[0], current[1] + 1)
            elif move == 'W' and current[1] > 0 and maze[current[0]][current[1] - 1] != '#':
                next_step = (current[0], current[1] - 1)

            if next_step != current:  # Ensuring no loops
                current = next_step
                path.append(current)
        population.append(path)
    return population


def fitness(path, end):
    distance_to_end = abs(end[0] - path[-1][0]) + abs(end[1] - path[-1][1]) #manhattan distance abs(y difference) + abs(x difference)
    return 1 / (len(path) + distance_to_end) #shorter paths are better -- lamma na3mel 1 over path so8ayyar 7aykoon el fitness bta3o akbar


def mutate(path, maze, end, rows, columns): #maze is a 2D array
    index = random.randint(1, len(path) - 2) #me4 3ayzeen ne8ayyar el end wala el start
    path = path[:index] #selects the first portion of a random path
    current = path[-1]
    while current != end:
        move = random.choice(['N', 'S', 'E', 'W'])
        next_step = current
        if move == 'N' and current[0] > 0 and maze[current[0] - 1][current[1]] != '#':
            next_step = (current[0] - 1, current[1])
        elif move == 'S' and current[0] < rows - 1 and maze[current[0] + 1][current[1]] != '#':
            next_step = (current[0] + 1, current[1])
        elif move == 'E' and current[1] < columns - 1 and maze[current[0]][current[1] + 1] != '#':
            next_step = (current[0], current[1] + 1)
        elif move == 'W' and current[1] > 0 and maze[current[0]][current[1] - 1] != '#':
            next_step = (current[0], current[1] - 1)

        if next_step != current:  # Ensuring no loops
            current = next_step
            path.append(current)
    return path


def crossover(parent1, parent2):
    min_len = min(len(parent1), len(parent2))
    for i in range(1, min_len):
        if parent1[i] == parent2[i]:
            continue
        else:
            return parent1[:i] + parent2[i:] #beya5odd goz2 men da we goz2 men da
    return parent1[:min_len]  # Default to taking the path up to the minimum length


def genetic_algorithm(maze, start, end, pop_size=400, generations=100):
    rows, columns = len(maze), len(maze[0])
    population = generate_population(start, end, pop_size, maze, rows, columns)

    for generation in range(generations):
        population = sorted(population, key=lambda x: fitness(x, end), reverse=True) #a3la fitness a7san 7aga -- maximizing

        if fitness(population[0], end) == 1:
            print(f"Solution found in generation {generation}")
            return population[0]

        next_population = population[:pop_size // 2] #the top half beykamel ma3ana

        while len(next_population) < pop_size:
            parent1 = random.choice(population[:pop_size // 4])
            parent2 = random.choice(population[:pop_size // 4])
            child = crossover(parent1, parent2)
            next_population.append(mutate(child, maze, end, rows, columns))

        population = next_population

    return population[0]  # Return the best solution found


# # Main execution
# maze = parse_maze('maze.txt')
# start, end = find_start_and_end(maze)
# final_path = genetic_algorithm(maze, start, end)


# # Mark the solution on the maze
# maze_solution = [row[:] for row in maze]
# for step in final_path:
#     maze_solution[step[0]][step[1]] = 'o'

# maze_to_image(maze_solution, final_path)


import tkinter as tk
from tkinter import filedialog, Canvas
from PIL import Image, ImageDraw
from queue import PriorityQueue, Queue
from collections import deque
import tkinter as tk
from tkinter import filedialog, Canvas

class Node:
    def __init__(self, state, parent=None, action=None, g=0, heuristic=0):
        self.state = state
        self.parent = parent
        self.action = action
        self.g = g  # Cost to reach this node
        self.heuristic = heuristic  # Estimated cost to reach the goal (for A*)

    def f(self):
        return self.g + self.heuristic  # Total cost function f = g + h

    def __lt__(self, other):
        return self.f() < other.f()

    def __eq__(self, other):
        return self.state == other.state

    def __hash__(self):
        return hash(self.state)

class StackFrontier:
    def __init__(self):
        self.frontier = []

    def add(self, node):
        self.frontier.append(node)

    def contains_state(self, state):
        return any(node.state == state for node in self.frontier)

    def empty(self):
        return len(self.frontier) == 0

    def remove(self):
        if self.empty():
            raise Exception("empty frontier")
        else:
            return self.frontier.pop()

class QueueFrontier(StackFrontier):
    def remove(self):
        if self.empty():
            raise Exception("empty frontier")
        else:
            return self.frontier.pop(0)

class Maze:
    def __init__(self, filename):
        with open(filename) as f:
            contents = f.read()

        if contents.count("A") != 1:
            raise Exception("maze must have exactly one start point")
        if contents.count("B") != 1:
            raise Exception("maze must have exactly one goal")

        contents = contents.splitlines()
        self.height = len(contents)
        self.width = max(len(line) for line in contents)

        self.walls = []
        for i in range(self.height):
            row = []
            for j in range(self.width):
                try:
                    if contents[i][j] == "A":
                        self.start = (i, j)
                        row.append(False)
                    elif contents[i][j] == "B":
                        self.goal = (i, j)
                        row.append(False)
                    elif contents[i][j] == " ":
                        row.append(False)
                    else:
                        row.append(True)
                except IndexError:
                    row.append(False)
            self.walls.append(row)

        self.solution = None
        self.num_explored = 0

    def print(self):
        solution = self.solution[1] if self.solution is not None else None
        print()
        for i, row in enumerate(self.walls):
            for j, col in enumerate(row):
                if col:
                    print("â–ˆ", end="")
                elif (i, j) == self.start:
                    print("A", end="")
                elif (i, j) == self.goal:
                    print("B", end="")
                elif solution is not None and (i, j) in solution:
                    print("*", end="")
                else:
                    print(" ", end="")
            print()
        print()

    def neighbors(self, state):
        row, col = state
        candidates = [
            ("up", (row - 1, col)),
            ("down", (row + 1, col)),
            ("left", (row, col - 1)),
            ("right", (row, col + 1))
        ]

        result = []
        for action, (r, c) in candidates:
            if 0 <= r < self.height and 0 <= c < self.width and not self.walls[r][c]:
                result.append((action, (r, c)))
        return result

    def solve_bfs(self):
        """Breadth-First Search"""
        self.num_explored = 0
        start = Node(state=self.start)
        frontier = QueueFrontier()
        frontier.add(start)
        self.explored = set()

        while True:
            if frontier.empty():
                print("Frontier is empty, no solution found")
                print("Explored States:", self.explored)
                raise Exception("no solution")

            node = frontier.remove()
            self.num_explored += 1

            if node.state == self.goal:
                actions = []
                cells = []
                while node.parent is not None:
                    actions.append(node.action)
                    cells.append(node.state)
                    node = node.parent
                actions.reverse()
                cells.reverse()
                self.solution = (actions, cells)
                return

            self.explored.add(node.state)

            for action, state in self.neighbors(node.state):
                if state not in self.explored and not any(node.state == state for node in frontier.frontier):
                    child = Node(state=state, parent=node, action=action)
                    frontier.add(child)

    def solve_dfs(self):
        """Depth-First Search"""
        self.num_explored = 0
        start = Node(state=self.start)
        frontier = StackFrontier()
        frontier.add(start)
        self.explored = set()

        while True:
            if frontier.empty():
                print("Frontier is empty, no solution found")
                print("Explored States:", self.explored)
                raise Exception("no solution")

            node = frontier.remove()
            self.num_explored += 1

            if node.state == self.goal:
                actions = []
                cells = []
                while node.parent is not None:
                    actions.append(node.action)
                    cells.append(node.state)
                    node = node.parent
                actions.reverse()
                cells.reverse()
                self.solution = (actions, cells)
                return

            self.explored.add(node.state)

            for action, state in self.neighbors(node.state):
                if state not in self.explored and not any(node.state == state for node in frontier.frontier):
                    child = Node(state=state, parent=node, action=action)
                    frontier.add(child)

    def solve_greedy(self):
        """Greedy Best-First Search"""
        self.num_explored = 0
        start = Node(state=self.start, heuristic=self.manhattan_distance(self.start))
        frontier = QueueFrontier()
        frontier.add(start)
        self.explored = set()

        while True:
            if frontier.empty():
                print("Frontier is empty, no solution found")
                print("Explored States:", self.explored)
                raise Exception("no solution")

            node = frontier.remove()
            self.num_explored += 1

            if node.state == self.goal:
                actions = []
                cells = []
                while node.parent is not None:
                    actions.append(node.action)
                    cells.append(node.state)
                    node = node.parent
                actions.reverse()
                cells.reverse()
                self.solution = (actions, cells)
                return

            self.explored.add(node.state)

            for action, state in self.neighbors(node.state):
                if state not in self.explored and not any(node.state == state for node in frontier.frontier):
                    heuristic = self.manhattan_distance(state)
                    child = Node(state=state, parent=node, action=action, heuristic=heuristic)
                    frontier.add(child)

    def solve_a_star(self):
        """A* Search"""
        self.num_explored = 0
        start = Node(state=self.start, g=0, heuristic=self.manhattan_distance(self.start))
        frontier = PriorityQueue()
        frontier.put(start)
        self.explored = set()

        while True:
            if frontier.empty():
                print("Frontier is empty, no solution found")
                print("Explored States:", self.explored)
                raise Exception("no solution")

            node = frontier.get()
            self.num_explored += 1

            if node.state == self.goal:
                actions = []
                cells = []
                while node.parent is not None:
                    actions.append(node.action)
                    cells.append(node.state)
                    node = node.parent
                actions.reverse()
                cells.reverse()
                self.solution = (actions, cells)
                return

            self.explored.add(node.state)

            for action, state in self.neighbors(node.state):
                if state not in self.explored and not any(node.state == state for node in frontier.queue):
                    g = node.g + 1
                    heuristic = self.manhattan_distance(state)
                    child = Node(state=state, parent=node, action=action, g=g, heuristic=heuristic)
                    frontier.put(child)

    def manhattan_distance(self, state):
        row, col = state
        goal_row, goal_col = self.goal
        return abs(row - goal_row) + abs(col - goal_col)

    def display_map(self, show_solution=True, show_explored=True):
        cell_size = 50  # Increase this size for larger cells
        rows = len(self.walls)
        cols = len(self.walls[0])
        print(self.walls)
        # Resize the canvas based on the maze size
        canvas.config(width=cols * cell_size, height=rows * cell_size)
        canvas.delete("all")
        solution = self.solution[1] if self.solution is not None else None
        for i, row in enumerate(self.walls):
            for j, col in enumerate(row):
               if col:  # Wall
                    color = "#000000"  # Dark Gray
               elif (i, j) == self.start:  # Start point
                    color = "#0000FF"  # Bright Red
               elif (i, j) == self.goal:  # Goal point
                    color = "#008000"  # Bright Green
               elif solution is not None and show_solution and (i, j) in solution:  # Solution path
                    color = "#FFFF00"  # Gold
               elif show_explored and (i, j) in self.explored:  # Explored path
                    color = "#D3D3D3"  # Sky Blue
               else:  # Empty space
                    color = "#FFFFFF"  # Light Pink
               canvas.create_rectangle(j * cell_size, i * cell_size, 
                                        (j + 1) * cell_size, (i + 1) * cell_size, 
                                        fill=color, outline="#2F4F4F")

choosenfile = None

# Function to load the map and display it
def load_map():
    file_path = filedialog.askopenfilename(filetypes=[("Text files", "*.txt")])
    if file_path:
        try:
            with open(file_path, 'r') as file:
                maze_data = file.readlines()
                print(maze_data)
                global choosenfile
                choosenfile = file_path
            display_maze(maze_data)
        except Exception as e:
            tk.messagebox.showerror("Error", f"Failed to load map: {e}")

# Function to display the maze
def display_maze(maze_data):
    cell_size = 50
    rows = len(maze_data)
    cols = len(maze_data[0])

    canvas.config(scrollregion=(0, 0, cols * cell_size, rows * cell_size))

    canvas.delete("all")
    for y, line in enumerate(maze_data):
        for x, char in enumerate(line):
            if char == "#":
                color = "#000000"
            elif char == " ":
                color = "#FFFFFF"
            elif char == "A":
                color = "#0000FF"
            elif char == "B":
                color = "#008000"
            else:
                continue
            canvas.create_rectangle(x * cell_size, y * cell_size,
                                    (x + 1) * cell_size, (y + 1) * cell_size,
                                    fill=color, outline="#2F4F4F")

# Function to handle algorithm selection
def on_algorithm_change():
    selected_algorithm = algorithm_var.get()
    if choosenfile is None:
        tk.messagebox.showwarning("No Map Loaded", "Please load a map first.")
        return

    # Show loading indicator
    loading_frame.grid(row=5, column=0, pady=10)
    root.update_idletasks()  # Update the UI to show the loading frame

    # Schedule algorithm execution after a short delay
    if not selected_algorithm=="GA" :
        root.after(500, lambda: run_algorithm(selected_algorithm))
    else :
        run_algorithm(selected_algorithm)
        
def run_algorithm(selected_algorithm):
    try:
        m = Maze(choosenfile)
        if selected_algorithm == "BFS":
            m.solve_bfs()
            m.display_map()
        elif selected_algorithm == "DFS":
            m.solve_dfs()
            m.display_map()
        elif selected_algorithm == "A*":
            m.solve_a_star()
            m.display_map()
        elif selected_algorithm == "GA":
            # Main execution
            maze = parse_maze(choosenfile)
            start, end = find_start_and_end(maze)
            final_path = genetic_algorithm(maze, start, end)
            # Mark the solution on the maze
            maze_solution = [row[:] for row in maze]
            for step in final_path:
                maze_solution[step[0]][step[1]] = 'o'
            maze_solution[final_path[-1][0]][final_path[-1][1]] = 'B'
            maze_solution[final_path[0][0]][final_path[0][1]] = 'A'

            maze_to_image(maze_solution, final_path)
    finally:
        # Hide loading indicator after processing
        root.after(0, lambda: loading_frame.grid_forget())

def update_spinner():
    # Update spinner text to create animation effect
    global spinner_frame
    spinner_frame = (spinner_frame + 1) % len(spinner_frames)
    spinning_label.config(text=spinner_frames[spinner_frame])
    root.after(100, update_spinner)  # Update every 100 milliseconds

# Create the main window
root = tk.Tk()
root.title("Maze Solver")
root.configure(bg="#F0F0F0")

# Set a fixed size for the root window
window_width = 1000
window_height = 800
root.geometry(f"{window_width}x{window_height}")

# Center the root window on the screen
screen_width = root.winfo_screenwidth()
screen_height = root.winfo_screenheight()
position_right = int(screen_width/2 - window_width/2)
position_down = int(screen_height/2 - window_height/2)
root.geometry(f"+{position_right}+{position_down}")

root.resizable(False, False)

# Create a frame for the left side with buttons and radio buttons
left_frame = tk.Frame(root, bg="#F0F0F0")
left_frame.grid(row=0, column=0, padx=20, pady=20)

# Create the Enter Maze button
enter_button = tk.Button(left_frame, text="Enter Maze", command=load_map,
                         font=("Arial", 14), bg="#6a98f0", fg="white",
                         activebackground="#557cbd", relief="raised")
enter_button.grid(row=0, column=0, pady=10, sticky="ew")

# Create radio buttons for algorithm selection
algorithm_var = tk.StringVar(value="BFS")

algorithms = [("BFS", "BFS"), ("DFS", "DFS"), 
              ("Heuristic Search (A*)", "A*"), 
              ("Genetic Algorithm", "GA")]

for idx, (text, value) in enumerate(algorithms):
    tk.Radiobutton(left_frame, text=text, variable=algorithm_var, value=value,
                   font=("Arial", 12), bg="#F0F0F0", fg="#4c4c4c",
                   activebackground="#f0d9b5", selectcolor="#c7c7c7",
                   command=on_algorithm_change).grid(row=idx+1, column=0, sticky="w", pady=5)

# Create a frame to hold the loading label and spinner
loading_frame = tk.Frame(left_frame, bg="#F0F0F0")
loading_label = tk.Label(loading_frame, text="Loading...", font=("Arial", 12), bg="#F0F0F0", fg="red")
spinner_frames = ['|', '/', '-', '\\']
spinner_frame = 0
spinning_label = tk.Label(loading_frame, text=spinner_frames[spinner_frame], font=("Arial", 12), bg="#F0F0F0", fg="red")

loading_label.pack(side="left")
spinning_label.pack(side="left", padx=5)  # Add some padding between the label and spinner

# Create the canvas to display the maze, positioned at the bottom right
canvas = Canvas(root, width=600, height=600, bg="#ffffff", bd=2, relief="sunken")
canvas.grid(row=1, column=1, padx=20, pady=20, sticky="se")

# Start the spinning animation (but keep it hidden initially)
update_spinner()

# Run the main loop
root.mainloop()
