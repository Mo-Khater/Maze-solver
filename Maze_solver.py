# -*- coding: utf-8 -*-
"""Untitled32 (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qhEhRp3l8SXUDSP4qWATOOuhf9QdTDdB
"""
import tkinter as tk
from tkinter import filedialog, Canvas
import tkinter.messagebox
from PIL import Image, ImageDraw
from queue import PriorityQueue, Queue
from collections import deque
import tkinter as tk
from tkinter import filedialog, Canvas
import threading

class Node:
    def __init__(self, state, parent=None, action=None, g=0, heuristic=0):
        self.state = state
        self.parent = parent
        self.action = action
        self.g = g  # Cost to reach this node
        self.heuristic = heuristic  # Estimated cost to reach the goal (for A*)

    def f(self):
        return self.g + self.heuristic  # Total cost function f = g + h

    def __lt__(self, other):
        return self.f() < other.f()

    def __eq__(self, other):
        return self.state == other.state

    def __hash__(self):
        return hash(self.state)

class StackFrontier:
    def __init__(self):
        self.frontier = []

    def add(self, node):
        self.frontier.append(node)

    def contains_state(self, state):
        return any(node.state == state for node in self.frontier)

    def empty(self):
        return len(self.frontier) == 0

    def remove(self):
        if self.empty():
            raise Exception("empty frontier")
        else:
            return self.frontier.pop()

class QueueFrontier(StackFrontier):
    def remove(self):
        if self.empty():
            raise Exception("empty frontier")
        else:
            return self.frontier.pop(0)

class Maze:
    def __init__(self, filename):
        with open(filename) as f:
            contents = f.read()

        if contents.count("A") != 1:
            raise Exception("maze must have exactly one start point")
        if contents.count("B") != 1:
            raise Exception("maze must have exactly one goal")

        contents = contents.splitlines()
        self.height = len(contents)
        self.width = max(len(line) for line in contents)

        self.walls = []
        for i in range(self.height):
            row = []
            for j in range(self.width):
                try:
                    if contents[i][j] == "A":
                        self.start = (i, j)
                        row.append(False)
                    elif contents[i][j] == "B":
                        self.goal = (i, j)
                        row.append(False)
                    elif contents[i][j] == " ":
                        row.append(False)
                    else:
                        row.append(True)
                except IndexError:
                    row.append(False)
            self.walls.append(row)

        self.solution = None
        self.num_explored = 0

    def print(self):
        solution = self.solution[1] if self.solution is not None else None
        print()
        for i, row in enumerate(self.walls):
            for j, col in enumerate(row):
                if col:
                    print("â–ˆ", end="")
                elif (i, j) == self.start:
                    print("A", end="")
                elif (i, j) == self.goal:
                    print("B", end="")
                elif solution is not None and (i, j) in solution:
                    print("*", end="")
                else:
                    print(" ", end="")
            print()
        print()

    def neighbors(self, state):
        row, col = state
        candidates = [
            ("up", (row - 1, col)),
            ("down", (row + 1, col)),
            ("left", (row, col - 1)),
            ("right", (row, col + 1))
        ]

        result = []
        for action, (r, c) in candidates:
            if 0 <= r < self.height and 0 <= c < self.width and not self.walls[r][c]:
                result.append((action, (r, c)))
        return result

    def solve_bfs(self):
        """Breadth-First Search"""
        self.num_explored = 0
        start = Node(state=self.start)
        frontier = QueueFrontier()
        frontier.add(start)
        self.explored = set()

        while True:
            if frontier.empty():
                print("Frontier is empty, no solution found")
                print("Explored States:", self.explored)
                raise Exception("no solution")

            node = frontier.remove()
            self.num_explored += 1

            if node.state == self.goal:
                actions = []
                cells = []
                while node.parent is not None:
                    actions.append(node.action)
                    cells.append(node.state)
                    node = node.parent
                actions.reverse()
                cells.reverse()
                self.solution = (actions, cells)
                return

            self.explored.add(node.state)

            for action, state in self.neighbors(node.state):
                if state not in self.explored and not any(node.state == state for node in frontier.frontier):
                    child = Node(state=state, parent=node, action=action)
                    frontier.add(child)

    def solve_dfs(self):
        """Depth-First Search"""
        self.num_explored = 0
        start = Node(state=self.start)
        frontier = StackFrontier()
        frontier.add(start)
        self.explored = set()

        while True:
            if frontier.empty():
                print("Frontier is empty, no solution found")
                print("Explored States:", self.explored)
                raise Exception("no solution")

            node = frontier.remove()
            self.num_explored += 1

            if node.state == self.goal:
                actions = []
                cells = []
                while node.parent is not None:
                    actions.append(node.action)
                    cells.append(node.state)
                    node = node.parent
                actions.reverse()
                cells.reverse()
                self.solution = (actions, cells)
                return

            self.explored.add(node.state)

            for action, state in self.neighbors(node.state):
                if state not in self.explored and not any(node.state == state for node in frontier.frontier):
                    child = Node(state=state, parent=node, action=action)
                    frontier.add(child)

    def solve_greedy(self):
        """Greedy Best-First Search"""
        self.num_explored = 0
        start = Node(state=self.start, heuristic=self.manhattan_distance(self.start))
        frontier = QueueFrontier()
        frontier.add(start)
        self.explored = set()

        while True:
            if frontier.empty():
                print("Frontier is empty, no solution found")
                print("Explored States:", self.explored)
                raise Exception("no solution")

            node = frontier.remove()
            self.num_explored += 1

            if node.state == self.goal:
                actions = []
                cells = []
                while node.parent is not None:
                    actions.append(node.action)
                    cells.append(node.state)
                    node = node.parent
                actions.reverse()
                cells.reverse()
                self.solution = (actions, cells)
                return

            self.explored.add(node.state)

            for action, state in self.neighbors(node.state):
                if state not in self.explored and not any(node.state == state for node in frontier.frontier):
                    heuristic = self.manhattan_distance(state)
                    child = Node(state=state, parent=node, action=action, heuristic=heuristic)
                    frontier.add(child)

    def solve_a_star(self):
        """A* Search"""
        self.num_explored = 0
        start = Node(state=self.start, g=0, heuristic=self.manhattan_distance(self.start))
        frontier = PriorityQueue()
        frontier.put(start)
        self.explored = set()

        while True:
            if frontier.empty():
                print("Frontier is empty, no solution found")
                print("Explored States:", self.explored)
                raise Exception("no solution")

            node = frontier.get()
            self.num_explored += 1

            if node.state == self.goal:
                actions = []
                cells = []
                while node.parent is not None:
                    actions.append(node.action)
                    cells.append(node.state)
                    node = node.parent
                actions.reverse()
                cells.reverse()
                self.solution = (actions, cells)
                return

            self.explored.add(node.state)

            for action, state in self.neighbors(node.state):
                if state not in self.explored and not any(node.state == state for node in frontier.queue):
                    g = node.g + 1
                    heuristic = self.manhattan_distance(state)
                    child = Node(state=state, parent=node, action=action, g=g, heuristic=heuristic)
                    frontier.put(child)

    def manhattan_distance(self, state):
        row, col = state
        goal_row, goal_col = self.goal
        return abs(row - goal_row) + abs(col - goal_col)

    def display_map(self, show_solution=True, show_explored=True):
        cell_size = 50  # Increase this size for larger cells
        rows = len(self.walls)
        cols = len(self.walls[0])
        print(self.walls)
        # Resize the canvas based on the maze size
        canvas.config(width=cols * cell_size, height=rows * cell_size)
        canvas.delete("all")
        solution = self.solution[1] if self.solution is not None else None
        for i, row in enumerate(self.walls):
            for j, col in enumerate(row):
               if col:  # Wall
                    color = "#000000"  # Dark Gray
               elif (i, j) == self.start:  # Start point
                    color = "#0000FF"  # Bright Red
               elif (i, j) == self.goal:  # Goal point
                    color = "#008000"  # Bright Green
               elif solution is not None and show_solution and (i, j) in solution:  # Solution path
                    color = "#FFFF00"  # Gold
               elif show_explored and (i, j) in self.explored:  # Explored path
                    color = "#D3D3D3"  # Sky Blue
               else:  # Empty space
                    color = "#FFFFFF"  # Light Pink
               canvas.create_rectangle(j * cell_size, i * cell_size, 
                                        (j + 1) * cell_size, (i + 1) * cell_size, 
                                        fill=color, outline="#2F4F4F")

choosenfile = None

# Function to load the map and display it
def load_map():
    file_path = filedialog.askopenfilename(filetypes=[("Text files", "*.txt")])
    if file_path:
        try:
            with open(file_path, 'r') as file:
                maze_data = file.readlines()
                print(maze_data)
                global choosenfile
                choosenfile = file_path
            display_maze(maze_data)
        except Exception as e:
            tk.messagebox.showerror("Error", f"Failed to load map: {e}")

# Function to display the maze
def display_maze(maze_data):
    cell_size = 50
    rows = len(maze_data)
    cols = len(maze_data[0].strip())

    canvas.config(scrollregion=(0, 0, cols * cell_size, rows * cell_size))

    canvas.delete("all")
    for y, line in enumerate(maze_data):
        for x, char in enumerate(line):
            if char == "#":
                color = "#000000"
            elif char == " ":
                color = "#FFFFFF"
            elif char == "A":
                color = "#0000FF"
            elif char == "B":
                color = "#008000"
            else:
                continue
            canvas.create_rectangle(x * cell_size, y * cell_size,
                                    (x + 1) * cell_size, (y + 1) * cell_size,
                                    fill=color, outline="#2F4F4F")

# Function to handle algorithm selection
def on_algorithm_change():
    selected_algorithm = algorithm_var.get()
    if choosenfile is None:
        tk.messagebox.showwarning("No Map Loaded", "Please load a map first.")
        return

    # Show loading indicator
    loading_frame.grid(row=5, column=0, pady=10)
    root.update_idletasks()  # Update the UI to show the loading frame

    # Schedule algorithm execution after a short delay
    root.after(1500, lambda: run_algorithm(selected_algorithm))

def run_algorithm(selected_algorithm):
    try:
        m = Maze(choosenfile)
        if selected_algorithm == "BFS":
            m.solve_bfs()
        elif selected_algorithm == "DFS":
            m.solve_dfs()
        elif selected_algorithm == "A*":
            m.solve_a_star()
        elif selected_algorithm == "GA":
            m.solve_ga()  # Assuming you have a GA method
        m.display_map()
    finally:
        # Hide loading indicator after processing
        root.after(0, lambda: loading_frame.grid_forget())

def update_spinner():
    # Update spinner text to create animation effect
    global spinner_frame
    spinner_frame = (spinner_frame + 1) % len(spinner_frames)
    spinning_label.config(text=spinner_frames[spinner_frame])
    root.after(100, update_spinner)  # Update every 100 milliseconds

# Create the main window
root = tk.Tk()
root.title("Maze Solver")
root.configure(bg="#F0F0F0")

# Set a fixed size for the root window
window_width = 1000
window_height = 800
root.geometry(f"{window_width}x{window_height}")

# Center the root window on the screen
screen_width = root.winfo_screenwidth()
screen_height = root.winfo_screenheight()
position_right = int(screen_width/2 - window_width/2)
position_down = int(screen_height/2 - window_height/2)
root.geometry(f"+{position_right}+{position_down}")

root.resizable(False, False)

# Create a frame for the left side with buttons and radio buttons
left_frame = tk.Frame(root, bg="#F0F0F0")
left_frame.grid(row=0, column=0, padx=20, pady=20)

# Create the Enter Maze button
enter_button = tk.Button(left_frame, text="Enter Maze", command=load_map,
                         font=("Arial", 14), bg="#6a98f0", fg="white",
                         activebackground="#557cbd", relief="raised")
enter_button.grid(row=0, column=0, pady=10, sticky="ew")

# Create radio buttons for algorithm selection
algorithm_var = tk.StringVar(value="BFS")

algorithms = [("BFS", "BFS"), ("DFS", "DFS"), 
              ("Heuristic Search (A*)", "A*"), 
              ("Genetic Algorithm", "GA")]

for idx, (text, value) in enumerate(algorithms):
    tk.Radiobutton(left_frame, text=text, variable=algorithm_var, value=value,
                   font=("Arial", 12), bg="#F0F0F0", fg="#4c4c4c",
                   activebackground="#f0d9b5", selectcolor="#c7c7c7",
                   command=on_algorithm_change).grid(row=idx+1, column=0, sticky="w", pady=5)

# Create a frame to hold the loading label and spinner
loading_frame = tk.Frame(left_frame, bg="#F0F0F0")
loading_label = tk.Label(loading_frame, text="Loading...", font=("Arial", 12), bg="#F0F0F0", fg="red")
spinner_frames = ['|', '/', '-', '\\']
spinner_frame = 0
spinning_label = tk.Label(loading_frame, text=spinner_frames[spinner_frame], font=("Arial", 12), bg="#F0F0F0", fg="red")

loading_label.pack(side="left")
spinning_label.pack(side="left", padx=5)  # Add some padding between the label and spinner

# Create the canvas to display the maze, positioned at the bottom right
canvas = Canvas(root, width=600, height=600, bg="#ffffff", bd=2, relief="sunken")
canvas.grid(row=1, column=1, padx=20, pady=20, sticky="se")

# Start the spinning animation (but keep it hidden initially)
update_spinner()

# Run the main loop
root.mainloop()
